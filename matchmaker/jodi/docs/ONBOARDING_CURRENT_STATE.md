# Jodi ‚Äî User Onboarding: Current State (shreya)

Summary
- Created a concise current-state document describing onboarding flows, Telegram UI, technical architecture, memory, and gaps.
- Source: codebase under /matchmaker/jodi/ (bot.py, conversation.py, db.py, matching.py).

1) User Journey Map (user perspective first)

Mermaid flow (user-first):

```mermaid
flowchart TD
  A[User opens Telegram & messages Jodi (/start)] --> B{Does user have profile?}
  B -- No --> C[Bot: Welcome message (conversational)]
  C --> D[Bot asks first "Tell me about yourself" question]
  D --> E[User replies]
  E --> F[Bot extracts demographics & preferences via ConversationManager (Claude)]
  F --> G{Stage complete?}
  G -- No --> H[Bot asks next natural question]
  H --> E
  G -- Yes --> I[Advance stages until 'complete']
  I --> J[Bot marks profile_complete and runs matching]
  J --> K[Bot shows top match with buttons (Interested / Pass / See more)]
  K --> L[User taps action -> DB updated -> potential notify other user]

  B -- Yes --> M[Bot: "Welcome back" with options (/matches /update /help)]
  M --> N[User can view matches or continue chatting]
```

ASCII quick map:
- Open bot (/start)
  - If first-time or incomplete: conversational welcome -> multi-session Q&A -> collect demographics/preferences -> review -> mark complete -> find & present matches
  - If returning & profile complete: present options (matches/update/help)

2) What Telegram Shows (actual messages / UI)

- /start
  - New user: welcome_msg from ConversationManager.get_welcome_message()
    "Namaste! üôè ... Tell me a bit about yourself! Who are you, what do you do?"
  - Returning: "Welcome back, <FirstName>! Your profile is complete. Would you like to: ‚Ä¢ See new matches (/matches) ‚Ä¢ Update your profile (/update) ‚Ä¢ Get help (/help)"

- During conversation
  - Bot sends single, natural questions generated by Claude (or fallback hardcoded questions).
  - User replies in free text.
  - Bot responds with next question or progress messages. Conversation is plain text messages.

- When matches found
  - Bot posts a text summary of top match, e.g.:
    "I found 3 potential matches for you! Here's someone I think you should meet:\nüìç Location\nüíº Occupation\nüéÇ Age\nüó£Ô∏è Language\nMatch score: 82.5/100\nWhy I think you'd connect:\n‚Ä¢ ..."
  - Inline keyboard with buttons:
    - üëç Interested (callback_data: match_yes_<id>)
    - üëé Pass (callback_data: match_no_<id>)
    - üîç See more matches (callback_data: see_more_matches)

- /matches
  - If none: "No matches yet! I'm still looking. üîç"
  - If some: short message then (TODO) show matches one-by-one

- /help
  - Markdown help text explaining commands and how the bot works.

3) New User Flow (first-time experience)
- Trigger: /start (or messaging bot for first time)
- create_user() called in DB
- DB.get_profile() returns none -> bot sends ConversationManager.get_welcome_message()
- update_conversation_state() sets stage: "getting_to_know"
- Conversation proceeds over multiple messages:
  - Each message is appended to conversation_history and passed to ConversationManager.process_user_response()
  - Claude extracts demographics/preferences/signals and returns updated_profile, stage_complete, next_stage
  - DB.create_or_update_profile() persists the profile & conversation_history
  - When stage_complete, DB.update_conversation_state() advances stage
  - After all stages reach "complete", DB.mark_profile_complete()
  - Bot informs user and calls find_and_present_matches()

4) Returning User Flow
- Trigger: /start
- DB.get_profile() exists and DB.get_user(...).profile_complete True
- Bot replies with a welcome-back message and options (/matches, /update, /help)
- /matches returns matches from DB.get_matches_for_user(status="proposed")
- User can continue conversation; conversation state is stored in DB.users.conversation_state and profiles.conversation_history

5) Behind the Scenes ‚Äî simplified technical flow

Components:
- Telegram Bot (bot.py) ‚Äî handlers: /start, /help, /matches, messages, callback queries
- ConversationManager (conversation.py) ‚Äî wraps Claude (Anthropic) for: get_welcome_message(), get_next_question(), process_user_response()
- Database (db.py) ‚Äî SQLite with tables: users, profiles, matches
- Matcher (matching.py) ‚Äî ContextualMatcher that scores candidates using weighted preferences & signals

Sequence (high level):
1. User message -> bot.handle_message
2. Load conversation state & profile from DB
3. Append user message to conversation_history
4. ConversationManager.process_user_response() calls Claude to extract structured profile updates
5. Merge result, persist via create_or_update_profile
6. If stage complete -> advance state; if "complete" -> mark_profile_complete and run matcher.find_matches()
7. Matcher scores all profiles and returns top matches
8. Store match proposals in DB.matches and present top match to user with inline buttons
9. User interactions on buttons update matches via CallbackQueryHandler -> update_match_status()

6) Context & Memory

Where context is stored:
- users.conversation_state (JSON) ‚Äî keeps current stage and timestamps
- profiles.conversation_history (JSON array) ‚Äî chronological messages with role and stage
- profiles.demographics / preferences / signals ‚Äî extracted structured memory for matching

How it's used:
- ConversationManager.get_next_question() uses the last ~6 messages and partial_profile to craft the next question via Claude
- process_user_response() builds an extraction prompt and asks Claude to return a JSON update, which is merged into the profile
- Matching uses demographics, preferences, and signals to compute contextual match scores

Memory characteristics:
- Persistent (SQLite)
- Conversation history is saved per-profile and used across sessions
- Profile fields contain both factual (demographics) and interpretive (signals, preference weights) data
- No explicit TTL or pruning logic (conversation_history can grow indefinitely)

7) Current Gaps / Issues (UX & technical)

UX gaps:
- No explicit onboarding progress indicator shown to user (they don't see "stage: getting_to_know") ‚Äî could confuse users about how many steps remain.
- Conversation can feel slow because stage completion depends on heuristics (exchanges >= N). No explicit "You're almost done" messaging.
- When API/Claude fails, fallback questions exist but no user-visible error handling or apology message.
- /update command is referenced but not implemented in code (TODO)
- Matches presentation: only top match implemented; "See more matches" is a placeholder
- No notifications implemented to inform other user when someone is interested (TODO)

Technical gaps:
- DB: two implementations exist in repo (db.py SQLite and db_postgres.py). Bot currently imports db_postgres.JodiDB ‚Äî need to reconcile differences and confirm deployment DB.
- No test coverage around ConversationManager prompts/results handling.
- No rate-limiting or queuing for Claude calls ‚Äî heavy traffic could lead to failures.
- No privacy/consent flow: collecting sensitive attributes (caste, family) has no explicit consent step or explanation.
- Conversation_history has no retention policy (privacy risk).

Files & code notes discovered:
- bot.py: main orchestration, uses db_postgres.JodiDB in this deployed entrypoint
- conversation.py: uses Anthropic client heavily; model names and prompts baked in
- db.py: SQLite implementation (used for local testing)
- matching.py: core matching logic with cultural compensation heuristics

Actionable recommendations (short)
- Surface progress: show a friendly progress message (e.g., "Just 2 more quick questions and I'll be ready to find matches")
- Implement /update and expand /matches flow to paginate matches and allow feedback
- Implement brief consent notice at welcome before extracting sensitive attributes
- Add graceful error messages for when AI/api calls fail and a retry/backoff
- Add retention policy and a command to export/delete user data
- Reconcile DB implementations and confirm production DB (postgres vs sqlite)

What I saved
- Saved this document to: /matchmaker/jodi/docs/ONBOARDING_CURRENT_STATE.md

---

End of report.
